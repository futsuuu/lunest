mod config;
mod global;
mod io;
mod process;

use std::io::Write;

use clap::Parser;
use crossterm::style::Stylize;

/// Lua testing framework
#[derive(Debug, Parser)]
#[command(version, about)]
enum Args {
    /// Run tests
    #[command(visible_alias = "r")]
    Run {
        /// Run tests with the specified profile
        #[arg(long, short, value_delimiter = ',')]
        profile: Vec<String>,
        /// Run tests with the profiles in the specified group
        #[arg(long, short, value_delimiter = ',')]
        group: Vec<String>,
    },

    /// Print wrapper Lua code used for in-source testing
    Wrapper {
        /// Write code into the specified file
        #[arg(long, short, value_name = "FILE")]
        save: Option<std::path::PathBuf>,
    },
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    match args {
        Args::Run { profile, group } => run_cmd(profile, group)?,
        Args::Wrapper { save } => wrapper_cmd(save)?,
    }
    Ok(())
}

#[test]
fn test_lua() -> anyhow::Result<()> {
    run_cmd(vec![], vec!["all".into()])
}

fn run_cmd(profiles: Vec<String>, groups: Vec<String>) -> anyhow::Result<()> {
    let cx = global::Context::new()?;

    let profiles = {
        let mut ps = Vec::new();
        for profile in &profiles {
            ps.push(cx.config().profile(profile)?);
        }
        for group in &groups {
            ps.extend(cx.config().group(group)?);
        }
        if ps.is_empty() {
            ps.push(cx.config().default_profile()?);
        }
        ps
    };

    let mut has_error = false;
    for (i, profile) in profiles.iter().enumerate() {
        if i != 0 {
            println!();
        }
        if !run(&cx, profile)? {
            has_error = true;
        }
    }
    if has_error {
        std::process::exit(1);
    }
    Ok(())
}

fn run(cx: &global::Context, profile: &config::Profile) -> anyhow::Result<bool> {
    println!("run with profile '{}'", profile.name().bold());

    let mut process = process::Process::spawn(cx, profile)?;
    process.write(&process::Input::Initialize {
        init_file: profile.init_script().clone(),
        root_dir: cx.root_dir().to_path_buf(),
        target_files: profile
            .target_files()
            .iter()
            .map(|p| process::TargetFile::new(p.clone(), cx.root_dir()))
            .collect(),
        term_width: crossterm::terminal::size().map_or(60, |size| size.0),
    })?;

    let mut results = Vec::new();
    println!();

    loop {
        let Some(request) = process.read()? else {
            if process.is_running()? {
                continue;
            } else {
                break;
            }
        };
        match request {
            process::Output::TestFinished(t) => {
                println!("{t}");
                results.push(t);
            }
            process::Output::TestStarted(t) => {
                print!("{t}{}", crossterm::cursor::MoveToColumn(0));
                _ = std::io::stdout().flush();
            }
        }
    }

    let (success, error): (Vec<_>, Vec<_>) = results.iter().partition(|r| r.success());
    println!(
        "\nsuccess: {}, error: {}",
        success.len().to_string().green(),
        error.len().to_string().red(),
    );
    Ok(error.is_empty())
}

fn wrapper_cmd(save: Option<std::path::PathBuf>) -> anyhow::Result<()> {
    let source = concat!(
        "-- Code generated by `lunest wrapper`. DO NOT EDIT.\n",
        "---@diagnostic disable\n",
        include_str!("../../module/lunest/wrapper.lua")
    );
    if let Some(path) = save {
        anyhow::ensure!(!path.exists(), "file already exists");
        std::fs::write(path, source)?;
    } else {
        print!("{}", source);
    }
    Ok(())
}
